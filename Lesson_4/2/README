2. Написать два алгоритма нахождения i-го по счёту простого числа. Функция нахождения простого числа должна принимать на вход натуральное и возвращать соответствующее простое число. Проанализировать скорость и сложность алгоритмов.
Первый — с помощью алгоритма «Решето Эратосфена».
Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков. Используйте этот код и попробуйте его улучшить/оптимизировать под задачу.
Второй — без использования «Решета Эратосфена».
Примечание. Вспомните классический способ проверки числа на простоту.

В данном задании написал два алгоритма в двух разных файлах.
В файл main импортированы оба этих алгоритма. Задаете любое n, учитывайте, что 0 элемента нет, а первый элемент это 2.
Сделал так исходя из примера в задании. Почему так для меня загадка.
>>> sieve(2)
3
>>> prime(4)
7
>>> sieve(5)
11
>>> prime(1)
2
Сами видите, первый элемент это 2. При вводе 0, функции вернут -1.
Не кидайтесь камнями, я делал исходя из этого пример, и не придумал, ничего лучше, как принять то, что мы индексируем с
1. Ибо самое число 1 не простое число. И какое число поставить на 0 позицию я не знал.

Оценка скорости алгоритма на основе решета Эратосфена:
10 элемент: 100 loops, best of 5: 20.7 usec per loop
100 элемент: 100 loops, best of 5: 2.97 msec per loop
200 элемент: 100 loops, best of 5: 14.3 msec per loop
500 элемент: 100 loops, best of 5: 113 msec per loop
1000 элемент: 10 loops, best of 5: 518 msec per loop

Оценка скорости алгоритма с проверкой простого числа:
10 элемент: 100 loops, best of 5: 12.8 usec per loop
100 элемент: 100 loops, best of 5: 399 usec per loop
200 элемент: 100 loops, best of 5: 1.11 msec per loop
500 элемент: 100 loops, best of 5: 4.56 msec per loop
1000 элемент: 100 loops, best of 5: 13.2 msec per loop
5000 элемент:100 loops, best of 5: 153 msec per loop

Как видим, второй алгоритм явно быстрее. Почему? Ну во-первых, решето Эратосфена, подразумевает выкалывание простых
чисел из ряда всех. Чтобы это сделать надо создать какой-то массив, чтоб его выкалывать. Для создания делается n^2
прохода, т.к. на какое число элементов задавать, я точно не знал, поэтому решил, что так будет рационально. Можно
задать размер исходя из пи-функции, как ее посчитать, я не понял. Во-вторых, мы имеем два вложенных цикла, когда
"выкалываем" простые числа. Увеличил скорость тем, что сразу закидываю просты элементы в массив и останавливаюсь, когда
размер массива равен n. Второй алгоритм быстрее по следующему ряду причин. Во-первых я делаю, n обходов. А функция
проверки простого числа имеет скорость О(n^(1/2)).
Так что, в первом случае мы имеем скорость: О(n^2) + O(n) = O(n(n + 1) по идее тут еще что-то плюсом к скорости, но
я точно затрудняюсь сказать. Но как факт, тут уже скорость n^2.
А во втором случае у нас скорость: O(n^(1/2)) + O(n) = O(n + n ^ (1/2))

А может я вообще какую-то ересь наплел. Как факт, по скорости прогнал, алгоритмы сравнил.
Вот такой вот эмпирический анализ алгоритмов)))